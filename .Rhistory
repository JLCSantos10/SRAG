lim_3 = media + 3 * sd,
.groups = "drop"
)
# Dados atuais (ano de refer√™ncia)
atual <- df_10 %>%
filter(ano == ano_ref) %>%
group_by(SE) %>%
summarise(casos = n(), pop = first(populacao), .groups = "drop") %>%
mutate(inc = 100000 * casos / pop)
#Nowcasting dos casos
# Calcular a m√©dia m√≥vel (lag = 1, para n√£o usar valores futuros)
atual <- atual %>%
arrange(SE) %>%
mutate(
inc_ma = rollmean(inc, k = 4, align = "right", fill = NA)
)
# √öltima SE registrada no ano de refer√™ncia
ultima_SE <- max(atual$SE, na.rm = TRUE)
# Fator de corre√ß√£o fixo (exemplo: 1.2). Voc√™ pode usar um nowcast_fator se quiser.
fator_nowcasting <- 1.2
# Corrigir nas 4 √∫ltimas semanas com base na m√©dia m√≥vel
nowcast <- atual %>%
filter(SE >= (ultima_SE - 8), SE <= ultima_SE-1) %>%
mutate(
inc_corrigida = inc_ma,
ic_low = inc_corrigida * 0.9,
ic_up  = inc_corrigida * 1.1
) %>%
drop_na(inc_corrigida)
# Gr√°fico
# üñº Gr√°fico com legenda
caption_text <- paste0(
"Anos de refer√™ncia para os limiares ",
min(filtro_ano), " a ", max(filtro_ano),
". Retirando o ano epid√™mico de:", ano_epidemico
)
ggplot() +
geom_ribbon(data = limiares, aes(x = SE, ymin = 0, ymax = media, fill = "Zona de controle"), alpha = 0.3) +
geom_ribbon(data = limiares, aes(x = SE, ymin = media, ymax = lim_1, fill = "Zona de seguran√ßa"), alpha = 0.3) +
geom_ribbon(data = limiares, aes(x = SE, ymin = lim_1, ymax = lim_2, fill = "Zona de alerta"), alpha = 0.3) +
geom_ribbon(data = limiares, aes(x = SE, ymin = lim_2, ymax = lim_3, fill = "Zona epid√™mica"), alpha = 0.3) +
geom_line(data = atual, aes(x = SE, y = inc, color = "Incidencia atual"), size = 1.2) +
# Nowcasting
geom_ribbon(data = nowcast, aes(x = SE, ymin = ic_low, ymax = ic_up),
fill = "gray50", alpha = 0.3) +
geom_line(data = nowcast, aes(x = SE, y = inc_corrigida, color = "Incidencia corrigida"),
linewidth = 1.2)+
labs(
x = "Semana Epidemiol√≥gica",
y = "Incid√™ncia por 100 mil hab.",
fill = "Faixas de risco",
color = "",
caption = caption_text
) +
scale_fill_manual(
values = c(
"Zona de controle" = "green",
"Zona de seguran√ßa" = "yellow",
"Zona de alerta" = "orange",
"Zona epid√™mica" = "red"
),
breaks = c("Zona de controle", "Zona de seguran√ßa", "Zona de alerta", "Zona epid√™mica")
)+
scale_color_manual(values = c("Incidencia atual" = "blue", "Incidencia corrigida" = "red")) +
theme_minimal() +
theme(legend.position = "right")
# Preparar base com incid√™ncia (como antes)
df_ra <- srag %>%
left_join(pop, by = c("ano", "municipio")) %>%
filter(!is.na(populacao)) %>%
mutate(incidencia = 100000 / populacao)
# Anos de hist√≥rico (excluindo anos epid√™micos)
anos_hist <- (ano_ref - 10):(ano_ref - 1)
anos_hist <- setdiff(anos_hist, ano_epidemico)
# Limiares por RA
historico_ra <- df_ra %>%
filter(ano %in% anos_hist) %>%
group_by(SE, municipio, ano) %>%  # <-- adiciona o ano
summarise(casos = n(), pop = first(populacao), .groups = "drop") %>%
mutate(inc = 100000 * casos / pop)
limiares_ra <- historico_ra %>%
group_by(SE, municipio) %>%
summarise(
media = mean(inc),
sd = sd(inc),
lim_1 = media - 2* sd,
lim_2 = media + 2 * sd,
lim_3 = media + 3 * sd,
.groups = "drop"
)
# Dados atuais
atual_ra <- df_ra %>%
filter(ano == ano_ref) %>%
group_by(SE, municipio) %>%
summarise(casos = n(), pop = mean(populacao), .groups = "drop") %>%
mutate(inc = 100000 * casos / pop) %>%
arrange(municipio, SE) %>%
group_by(municipio) %>%
mutate(inc_ma = zoo::rollmean(inc, k = 4, align = "right", fill = NA)) %>%
ungroup()
# √öltimas 5 semanas por RA
ultima_SE <- max(atual_ra$SE, na.rm = TRUE)
nowcast_ra <- atual_ra %>%
filter(SE >= (ultima_SE - 8), SE <= ultima_SE-1) %>%
mutate(
inc_corrigida = inc_ma,
ic_low = inc_corrigida * 0.9,
ic_up  = inc_corrigida * 1.1
) %>%
drop_na(inc_corrigida)
# Gr√°fico facetado por municipio
ggplot() +
geom_ribbon(data = limiares_ra, aes(x = SE, ymin = 0, ymax = media, fill = "Zona de controle"), alpha = 0.3) +
geom_ribbon(data = limiares_ra, aes(x = SE, ymin = media, ymax = lim_1, fill = "Zona de seguran√ßa"), alpha = 0.3) +
geom_ribbon(data = limiares_ra, aes(x = SE, ymin = lim_1, ymax = lim_2, fill = "Zona de alerta"), alpha = 0.3) +
geom_ribbon(data = limiares_ra, aes(x = SE, ymin = lim_2, ymax = lim_3, fill = "Zona epid√™mica"), alpha = 0.3) +
geom_line(data = atual_ra, aes(x = SE, y = inc, color = "Incid√™ncia atual"), linewidth = 1) +
geom_ribbon(data = nowcast_ra, aes(x = SE, ymin = ic_low, ymax = ic_up), fill = "gray50", alpha = 0.3) +
geom_line(data = nowcast_ra, aes(x = SE, y = inc_corrigida, color = "Incid√™ncia corrigida"),
linewidth = 1.1) +
facet_wrap(~municipio, scales = "free_y") +
scale_fill_manual(
values = c(
"Zona de controle" = "green",
"Zona de seguran√ßa" = "yellow",
"Zona de alerta" = "orange",
"Zona epid√™mica" = "red"
),
breaks = c("Zona de controle", "Zona de seguran√ßa", "Zona de alerta", "Zona epid√™mica")
) +
scale_color_manual(values = c(
"Incid√™ncia atual" = "blue",
"Incid√™ncia corrigida" = "red"
)) +
labs(
x = "Semana Epidemiol√≥gica",
y = "Incid√™ncia por 100 mil hab.",
fill = "Faixas de risco",
color = "",
caption = caption_text
) +
theme_minimal() +
theme(
legend.position = "right",
strip.text = element_text(face = "bold", size = 11)
)
gerar_tabela_diagrama_ra <- function(atual_ra, limiares_ra, nowcast_ra, ano) {
library(dplyr)
# Se n√£o tem nowcast, devolve tabela vazia padronizada
if (is.null(nowcast_ra) || nrow(nowcast_ra) == 0) {
return(tibble::tibble(
Zona_de_Risco = character(),
`municipio` = character(),
Recomenda√ß√£o = character()
))
}
ra_list <- unique(nowcast_ra$municipio)
cor_emojis <- c(
"zona de controle" = "<span style='color:#2ECC71'>&#9679;</span>",
"zona de seguran√ßa" = "<span style='color:#F1C40F'>&#9679;</span>",
"zona de alerta" = "<span style='color:#E67E22'>&#9679;</span>",
"zona epid√™mica" = "<span style='color:#E74C3C'>&#9679;</span>"
)
cor_nomes <- c(
"zona de controle" = "verde",
"zona de seguran√ßa" = "amarelo",
"zona de alerta" = "laranja",
"zona epid√™mica" = "vermelho"
)
linhas <- lapply(ra_list, function(ra) {
dados_limiar  <- limiares_ra %>% filter(municipio == ra)
dados_nowcast <- nowcast_ra %>% filter(municipio == ra) %>% arrange(SE)
# Se alguma RA n√£o tem limiar/nowcast, pula
if (nrow(dados_nowcast) == 0 || nrow(dados_limiar) == 0) return(NULL)
semanas_finais <- tail(sort(unique(dados_nowcast$SE)), 4)
if (length(semanas_finais) == 0) return(NULL)
zonas_finais <- dados_nowcast %>%
filter(SE %in% semanas_finais) %>%
left_join(dados_limiar, by = "SE") %>%
mutate(
zona = case_when(
inc_corrigida <= media ~ "zona de controle",
inc_corrigida <= lim_1 ~ "zona de seguran√ßa",
inc_corrigida <= lim_2 ~ "zona de alerta",
TRUE                   ~ "zona epid√™mica"
)
)
if (nrow(zonas_finais) == 0) return(NULL)
zona_predom <- zonas_finais %>%
count(zona) %>%
arrange(desc(n)) %>%
slice(1) %>%
pull(zona)
# Fallback se vier algo inesperado
if (is.na(zona_predom) || !(zona_predom %in% names(cor_emojis))) zona_predom <- "zona de controle"
emoji <- cor_emojis[[zona_predom]]
cor_nome <- cor_nomes[[zona_predom]]
delta <- if (nrow(dados_nowcast) >= 2) {
last(dados_nowcast$inc_corrigida) - dplyr::lag(dados_nowcast$inc_corrigida, 1) %>% last()
} else 0
tendencia <- case_when(
delta < -0.5 ~ "decl√≠nio",
delta > 0.5  ~ "aumento",
TRUE         ~ "estabilidade"
)
texto <- paste0(
"Nas √∫ltimas semanas, a incid√™ncia de SRAG manteve-se predominantemente na **",
emoji, " ", zona_predom, "**, com tend√™ncia de **", tendencia, "**. ",
"Recomenda-se ativar o n√≠vel **", cor_nome, "** do plano de conting√™ncia, com refor√ßo da vigil√¢ncia e aten√ß√£o aos indicadores locais."
)
tibble::tibble(
Zona_de_Risco = paste(emoji, zona_predom),
`municipio` = ra,
Recomenda√ß√£o = texto
)
})
out <- dplyr::bind_rows(linhas)
# Garante colunas mesmo se out estiver vazio
if (nrow(out) == 0) {
out <- tibble::tibble(
Zona_de_Risco = character(),
`municipio` = character(),
Recomenda√ß√£o = character()
)
}
out
}
tabela_diagrama <- gerar_tabela_diagrama_ra(atual_ra, limiares_ra, nowcast_ra, ano = ano_ref)
knitr::kable(
tabela_diagrama,
format = "pandoc",
escape = FALSE,
align = "l",
col.names = c("Zona de Risco", "municipio", "Recomenda√ß√£o")
)
# Lista com um gr√°fico por RA (faceteando os v√≠rus dentro de cada RA)
# Dicion√°rio de nomes corrigidos
# 1. Identificar colunas de PCR confirmadas
col_pcr <- grep("^PCR_", names(srag), value = TRUE)
col_pcr <- setdiff(col_pcr, "PCR_RESUL")
# 2. Base longa com v√≠rus confirmados
srag_long <- srag %>%
filter(ano == ano_ref)|>
select(municipio, DT_SIN_PRI, all_of(col_pcr)) %>%
pivot_longer(cols = all_of(col_pcr), names_to = "virus", values_to = "confirmado") %>%
filter(confirmado == 1, !is.na(DT_SIN_PRI)) %>%
mutate(
semana = epiweek(DT_SIN_PRI),
ano = year(DT_SIN_PRI),
virus_traduzido = virus_map[virus]
)
# 3. Incid√™ncia por semana, v√≠rus, RA
incidencia <- srag_long %>%
group_by(ano, semana, municipio, virus_traduzido) %>%
summarise(casos = n(), .groups = "drop") %>%
left_join(pop, by = c("ano", "municipio")) %>%
mutate(incidencia_100k = casos / populacao * 1e5)
# 4. Fun√ß√£o para calcular Rt por v√≠rus/RA
calcular_rt <- function(df) {
if (nrow(df) < 8) return(NULL)
incid <- df %>% arrange(ano, semana) %>% pull(casos)
config <- make_config(list(mean_si = 3.5, std_si = 2.5))
res <- tryCatch({
estimate_R(incid, method = "parametric_si", config = config)
}, error = function(e) NULL)
if (is.null(res)) return(NULL)
data.frame(
t = res$R$t_end,
Rt = res$R$`Mean(R)`,
low = res$R$`Quantile.0.025(R)`,
high = res$R$`Quantile.0.975(R)`,
semana = df$semana[res$R$t_end],
ano = df$ano[res$R$t_end],
municipio = df$municipio[1],
virus = df$virus_traduzido[1]
)
}
# 5. Aplicar por grupo
resultados_rt <- incidencia %>%
group_split(municipio, virus_traduzido) %>%
map_dfr(calcular_rt)
# ‚úÖ Guard rail
if (is.null(resultados_rt) || nrow(resultados_rt) == 0) {
cat(glue::glue(
"N√£o foi poss√≠vel estimar Rt para {ano_ref} (dados insuficientes por v√≠rus/RA, ou aus√™ncia de s√©ries com pelo menos 8 semanas).\n"
))
} else {
graficos_ra <- resultados_rt %>%
split(.$municipio) %>%
map(~ {
df_ra <- .x
# Se por algum motivo vier vazio, retorna NULL (ser√° removido depois)
if (nrow(df_ra) == 0) return(NULL)
ultima_semana <- df_ra %>%
group_by(virus) %>%
filter(semana == max(semana, na.rm = TRUE)) %>%
ungroup()
ggplot(df_ra, aes(x = semana, y = Rt)) +
geom_line(color = "#1f77b4") +
geom_ribbon(aes(ymin = low, ymax = high), fill = "#aec7e8", alpha = 0.3) +
geom_hline(yintercept = 1, linetype = "dashed", color = "red") +
geom_text(
data = ultima_semana,
aes(label = sprintf("Rt: %.2f", Rt)),
vjust = -0.5, hjust = 1, size = 5, color = "black"
) +
facet_wrap(~ virus, scales = "free_y", ncol = 2) +
labs(
title = unique(df_ra$municipio),
x = "Semana Epidemiol√≥gica", y = "Rt estimado"
) +
theme_minimal(base_size = 14)
})
# ‚úÖ Remove NULLs
graficos_ra <- purrr::compact(graficos_ra)
# ‚úÖ Se ficou vazio ap√≥s compact, n√£o chama wrap_plots
if (length(graficos_ra) == 0) {
cat(glue::glue(
"N√£o foi poss√≠vel gerar gr√°ficos de Rt para {ano_ref} (sem s√©ries v√°lidas ap√≥s filtragens).\n"
))
} else {
grid_completo <- patchwork::wrap_plots(graficos_ra, ncol = 2)
grid_completo
}
}
# ‚úÖ Se resultados_rt n√£o existe / est√° vazio, n√£o tenta interpretar
if (!exists("resultados_rt") || is.null(resultados_rt) || nrow(resultados_rt) == 0) {
cat(glue::glue(
"### Resumo por municipio ‚Äì Rt mais recente por v√≠rus\n\n",
"N√£o foi poss√≠vel estimar Rt para {ano_ref} (dados insuficientes por v√≠rus/RA ou s√©ries muito curtas).\n"
))
} else {
interpretacao_por_ra_virus <- resultados_rt %>%
# garante que a coluna existe mesmo em casos estranhos
dplyr::filter("Rt" %in% names(.)) %>%
dplyr::filter(!is.na(Rt)) %>%
dplyr::group_by(municipio, virus) %>%
dplyr::arrange(semana, .by_group = TRUE) %>%
dplyr::slice_tail(n = 1) %>%
dplyr::ungroup() %>%
dplyr::mutate(
Rt_atual = Rt,
Interpretacao = dplyr::case_when(
Rt_atual > 5 ~ glue(
"Na √∫ltima semana analisada, o Rt foi de **{round(Rt_atual, 2)}**, valor muito acima de 5, ",
"indicando transmiss√£o extremamente intensa e crescimento explosivo dos casos desse v√≠rus na regi√£o."
),
Rt_atual > 2 ~ glue(
"Na √∫ltima semana analisada, o Rt foi de **{round(Rt_atual, 2)}**, acima de 2, ",
"o que aponta para transmiss√£o muito intensa e r√°pida expans√£o dos casos, compat√≠vel com cen√°rio de forte aumento da circula√ß√£o viral."
),
Rt_atual > 1.05 ~ glue(
"Na √∫ltima semana analisada, o Rt foi de **{round(Rt_atual, 2)}**, acima de 1, ",
"sugerindo tend√™ncia de crescimento da transmiss√£o e possibilidade de aumento de casos nas semanas seguintes se n√£o houver refor√ßo nas medidas de controle."
),
Rt_atual >= 0.95 & Rt_atual <= 1.05 ~ glue(
"Na √∫ltima semana analisada, o Rt foi de **{round(Rt_atual, 2)}**, muito pr√≥ximo de 1, ",
"indicando um quadro de estabilidade, em que o n√∫mero de novos casos tende a se manter em patamar semelhante ao das semanas anteriores."
),
Rt_atual < 0.95 & Rt_atual >= 0.7 ~ glue(
"Na √∫ltima semana analisada, o Rt foi de **{round(Rt_atual, 2)}**, abaixo de 1, ",
"sugerindo redu√ß√£o gradual da transmiss√£o e tend√™ncia de queda lenta no n√∫mero de casos."
),
Rt_atual < 0.7 ~ glue(
"Na √∫ltima semana analisada, o Rt foi de **{round(Rt_atual, 2)}**, bem abaixo de 1, ",
"o que indica forte redu√ß√£o da transmiss√£o e prov√°vel queda acentuada dos casos desse v√≠rus na regi√£o."
),
TRUE ~ glue(
"Na √∫ltima semana analisada, o Rt foi de **{round(Rt_atual, 2)}**, ",
"sem evid√™ncias de aumento importante da transmiss√£o no per√≠odo."
)
)
) %>%
dplyr::select(`municipio`, V√≠rus = virus, Interpretacao)
cat("\n\n### Resumo por municipio ‚Äì Rt mais recente por v√≠rus\n\n")
# Se, ap√≥s filtros, n√£o sobrou nada:
if (nrow(interpretacao_por_ra_virus) == 0) {
cat(glue::glue(
"N√£o foi poss√≠vel gerar interpreta√ß√£o do Rt para {ano_ref} (sem estimativas v√°lidas).\n"
))
} else {
knitr::kable(interpretacao_por_ra_virus, format = "pandoc", align = "l")
}
}
setwd("~/GitHub/SRAG")
Sys.getenv("RSTUDIO_PANDOC")
setwd("~/GitHub/SRAG")
base::cat("Carregando arquivo CSV SRAG...\n")
srag_min_path <- "Bancos/SRAG.csv"
if (!base::file.exists(srag_min_path)) {
base::stop("Arquivo 'SRAG.csv' n√£o encontrado em ", srag_min_path)
}
srag <- readr::read_csv(srag_min_path, show_col_types = FALSE)
# üîπ Renomeia ID_MN_RESI_pad para municipio
if ("ID_MN_RESI_pad" %in% names(srag)) {
srag <- dplyr::rename(srag, municipio = ID_MN_RESI_pad)
} else {
base::stop("Coluna 'ID_MN_RESI_pad' n√£o encontrada na base SRAG.")
}
# üîπ Padroniza munic√≠pio
if ("municipio" %in% names(srag)) {
srag <- dplyr::mutate(
srag,
municipio = padronizar_nomes(municipio)
)
}
# üîπ Cria coluna ano
if (!"DT_SIN_PRI" %in% names(srag)) {
base::stop("Coluna 'DT_SIN_PRI' n√£o encontrada.")
}
if (!lubridate::is.Date(srag$DT_SIN_PRI) &&
!lubridate::is.POSIXct(srag$DT_SIN_PRI)) {
srag <- dplyr::mutate(
srag,
DT_SIN_PRI = lubridate::as_date(DT_SIN_PRI)
)
}
srag <- dplyr::mutate(
srag,
ano = lubridate::year(DT_SIN_PRI)
)
# üîπ Converte SE para inteiro
if ("SE" %in% names(srag)) {
srag <- dplyr::mutate(srag, SE = as.integer(SE))
}
base::cat("SRAG carregado com", nrow(srag), "linhas.\n")
# ---------------------------------------------------------
# üìå Carregar par√¢metros externos
# ---------------------------------------------------------
params_candidates <- c(
"params.yaml",
here::here("params.yaml"),
here::here("SRAG", "params.yaml")
)
params_path <- params_candidates[file.exists(params_candidates)][1]
if (is.na(params_path)) {
stop("Arquivo 'params.yaml' n√£o encontrado.")
}
params_externos <- yaml::read_yaml(params_path)
filtro_ano <- params_externos$filtro_ano
ano_epidemico <- params_externos$ano_epidemico
ano_ref <- params_externos$ano_ref
estado_sel <- params_externos$estado
municipio_sel <- params_externos$municipio
usar_filtro_municipio <- params_externos$usar_filtro_municipio
if (is.null(estado_sel)) {
stop("Par√¢metro 'estado' n√£o definido no params.yaml")
}
# ---------------------------------------------------------
# üìå Filtro por UF
# ---------------------------------------------------------
if ("SG_UF_NOT" %in% names(srag)) {
srag <- srag |>
dplyr::filter(SG_UF_NOT == estado_sel)
base::cat("Filtro aplicado para UF:", estado_sel, "\n")
base::cat("Casos ap√≥s filtro UF:", nrow(srag), "\n")
} else {
warning("Coluna 'SG_UF_NOT' n√£o encontrada na base SRAG.")
}
# ---------------------------------------------------------
# üìå Filtro opcional por munic√≠pio
# ---------------------------------------------------------
if (isTRUE(usar_filtro_municipio) &&
!is.null(municipio_sel)) {
municipio_sel_pad <- padronizar_nomes(municipio_sel)
srag <- srag |>
dplyr::filter(municipio == municipio_sel_pad)
base::cat("Filtro aplicado para munic√≠pio:", municipio_sel, "\n")
base::cat("Casos ap√≥s filtro munic√≠pio:", nrow(srag), "\n")
}
# ---------------------------------------------------------
# üìå Carregar base populacional
# ---------------------------------------------------------
pop_path <- "Bancos/POP.csv"
if (!file.exists(pop_path)) {
stop("Arquivo de popula√ß√£o n√£o encontrado em ", pop_path)
}
pop <- read.csv(pop_path)
# üîπ Padroniza munic√≠pio na base pop
if ("municipio" %in% names(pop)) {
pop <- pop |>
dplyr::mutate(
municipio = padronizar_nomes(municipio),
ano = as.numeric(ano)
)
} else if ("id_municipio_nome" %in% names(pop)) {
pop <- pop |>
dplyr::rename(municipio = id_municipio_nome) |>
dplyr::mutate(
municipio = padronizar_nomes(municipio),
ano = as.numeric(ano)
)
} else {
stop("Coluna de munic√≠pio n√£o encontrada na base POP.")
}
# üîπ Filtro por UF na popula√ß√£o
if ("sigla_uf" %in% names(pop)) {
pop <- pop |>
dplyr::filter(sigla_uf == estado_sel)
}
# üîπ Filtro opcional por munic√≠pio na popula√ß√£o
if (isTRUE(usar_filtro_municipio) &&
!is.null(municipio_sel)) {
municipio_sel_pad <- padronizar_nomes(municipio_sel)
pop <- pop |>
dplyr::filter(municipio == municipio_sel_pad)
}
base::cat("Base POP carregada com", nrow(pop), "linhas.\n")
# ---------------------------------------------------------
# üìå Pronto para cruzamento por:
# ano + municipio
# ---------------------------------------------------------
